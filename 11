import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeBase = cva(
  "inline-flex items-center rounded-full border text-xs font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none px-2.5 py-1",
  {
    variants: {
      variant: {
        default: "border-transparent bg-muted text-foreground",
        outline: "border-input bg-transparent",
        subtle: "border-transparent bg-muted/60 text-foreground",
      },
      size: {
        sm: "text-[10px] px-2 py-0.5",
        md: "text-xs px-2.5 py-1",
        lg: "text-sm px-3 py-1.5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeBase> {
  leadingIcon?: React.ReactNode;
  trailingIcon?: React.ReactNode;
  asChild?: boolean;
}

export function Badge({
  className,
  leadingIcon,
  trailingIcon,
  size,
  variant,
  children,
  ...props
}: BadgeProps) {
  return (
    <div className={cn(badgeBase({ size, variant }), className)} {...props}>
      {leadingIcon ? <span>{leadingIcon}</span> : null}
      {children}
      {trailingIcon ? <span>{trailingIcon}</span> : null}
    </div>
  );
}

export type DealLabel = "Profitable" | "Fair" | "Overpriced";
export type DealCode = "profitable" | "fair" | "overpriced";

export interface ScoreMeta {
  code: DealCode;
  label: DealLabel;
  confidence?: number;
  z?: number;
}

const recBadge = cva(
  "inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2",
  {
    variants: {
      tone: {
        profitable:
          "border-profitable/30 text-profitable-foreground bg-profitable-light dark:text-profitable-light",
        fair: "border-fair/30 text-fair-foreground bg-fair-light dark:text-fair-light",
        overpriced:
          "border-overpriced/30 text-overpriced-foreground bg-overpriced-light dark:text-overpriced-light",
      },
      size: {
        sm: "text-[10px] px-2 py-0.5",
        md: "text-xs px-2.5 py-1",
        lg: "text-sm px-3 py-1.5",
      },
      withDot: {
        true: "pl-2 pr-2.5",
        false: "",
      },
    },
    defaultVariants: {
      tone: "fair",
      size: "md",
      withDot: true,
    },
  }
);

function Dot({ className }: { className?: string }) {
  return <span className={cn("mr-1 h-2 w-2 rounded-full", className)} />;
}

const dotTone: Record<DealCode, string> = {
  profitable: "bg-profitable",
  fair: "bg-fair",
  overpriced: "bg-overpriced",
};

export interface RecommendationBadgeProps
  extends Omit<React.HTMLAttributes<HTMLDivElement>, "children"> {
  score: ScoreMeta | DealCode | DealLabel | null | undefined;
  size?: "sm" | "md" | "lg";
  showConfidence?: boolean;
  showZ?: boolean;
  i18n?: Partial<Record<DealLabel, string>>;
}

export function RecommendationBadge({
  score,
  size = "md",
  showConfidence = true,
  showZ = false,
  i18n,
  className,
  ...props
}: RecommendationBadgeProps) {
  const meta = normalizeScore(score);
  const translated =
    (i18n?.[meta.label] as string | undefined) ?? meta.label;

  return (
    <div
      className={cn(recBadge({ tone: meta.code, size }), className)}
      aria-label={meta.label}
      {...props}
    >
      <Dot className={dotTone[meta.code]} />
      {translated}
      {showConfidence && typeof meta.confidence === "number" ? (
        <span className="ml-1">({Math.round(meta.confidence * 100)}%)</span>
      ) : null}
      {showZ && typeof meta.z === "number" ? (
        <span className="ml-1">z={meta.z.toFixed(2)}</span>
      ) : null}
    </div>
  );
}

export function normalizeScore(
  input: RecommendationBadgeProps["score"]
): ScoreMeta {
  if (!input) return { code: "fair", label: "Fair" };
  if (typeof input === "string") {
    const lower = input.toLowerCase() as DealCode;
    switch (lower) {
      case "profitable":
        return { code: "profitable", label: "Profitable" };
      case "overpriced":
        return { code: "overpriced", label: "Overpriced" };
      case "fair":
        return { code: "fair", label: "Fair" };
    }
    return { code: "fair", label: "Fair" };
  }
  return {
    code: input.code,
    label: input.label,
    confidence: input.confidence,
    z: input.z,
  };
}
